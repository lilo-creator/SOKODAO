{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-8410cf325889d04bee75f9a04a81d58ee1444070",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/SOKODAO.sol": "project/contracts/SOKODAO.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/SOKODAO.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n \ncontract SOKODAO {\n    \n    // Product struct\n    struct Product {\n        uint256 id;\n        address seller;\n        string name;\n        string description;\n        string ipfsHash;      // IPFS hash for product images/metadata\n        uint256 price;        // Price in wei\n        uint256 stock;        // Available quantity\n        bool isActive;        // Product availability status\n        uint256 createdAt;\n    }\n    \n    // State variables\n    uint256 private productCounter;\n    mapping(uint256 => Product) public products;\n    mapping(address => uint256[]) private sellerProducts;\n    \n    // Events\n    event ProductListed(\n        uint256 indexed productId,\n        address indexed seller,\n        string name,\n        uint256 price,\n        uint256 stock\n    );\n    \n    event ProductUpdated(\n        uint256 indexed productId,\n        uint256 price,\n        uint256 stock,\n        bool isActive\n    );\n    \n    event ProductDeactivated(uint256 indexed productId);\n    \n    // Modifiers\n    modifier onlyProductOwner(uint256 _productId) {\n        require(products[_productId].seller == msg.sender, \"Not product owner\");\n        _;\n    }\n    \n    modifier validProduct(uint256 _productId) {\n        require(_productId > 0 && _productId <= productCounter, \"Invalid product ID\");\n        _;\n    }\n    \n    function listProduct(\n        string memory _name,\n        string memory _description,\n        string memory _ipfsHash,\n        uint256 _price,\n        uint256 _stock\n    ) external returns (uint256) {\n        require(bytes(_name).length > 0, \"Name cannot be empty\");\n        require(bytes(_ipfsHash).length > 0, \"IPFS hash required\");\n        require(_price > 0, \"Price must be greater than 0\");\n        require(_stock > 0, \"Stock must be greater than 0\");\n        \n        productCounter++;\n        \n        products[productCounter] = Product({\n            id: productCounter,\n            seller: msg.sender,\n            name: _name,\n            description: _description,\n            ipfsHash: _ipfsHash,\n            price: _price,\n            stock: _stock,\n            isActive: true,\n            createdAt: block.timestamp\n        });\n        \n        sellerProducts[msg.sender].push(productCounter);\n        \n        emit ProductListed(productCounter, msg.sender, _name, _price, _stock);\n        \n        return productCounter;\n    }\n    \n   \n    function updateProduct(\n        uint256 _productId,\n        uint256 _price,\n        uint256 _stock\n    ) external validProduct(_productId) onlyProductOwner(_productId) {\n        require(_price > 0, \"Price must be greater than 0\");\n        \n        Product storage product = products[_productId];\n        product.price = _price;\n        product.stock = _stock;\n        \n        emit ProductUpdated(_productId, _price, _stock, product.isActive);\n    }\n    \n    function toggleProductStatus(uint256 _productId) \n        external \n        validProduct(_productId) \n        onlyProductOwner(_productId) \n    {\n        Product storage product = products[_productId];\n        product.isActive = !product.isActive;\n        \n        if (!product.isActive) {\n            emit ProductDeactivated(_productId);\n        }\n        \n        emit ProductUpdated(_productId, product.price, product.stock, product.isActive);\n    }\n    \n    /**\n     * @dev Get product details\n     * @param _productId Product ID\n     */\n    function getProduct(uint256 _productId) \n        external \n        view \n        validProduct(_productId) \n        returns (\n            uint256 id,\n            address seller,\n            string memory name,\n            string memory description,\n            string memory ipfsHash,\n            uint256 price,\n            uint256 stock,\n            bool isActive,\n            uint256 createdAt\n        ) \n    {\n        Product memory product = products[_productId];\n        return (\n            product.id,\n            product.seller,\n            product.name,\n            product.description,\n            product.ipfsHash,\n            product.price,\n            product.stock,\n            product.isActive,\n            product.createdAt\n        );\n    }\n    \n \n    function getSellerProducts(address _seller) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return sellerProducts[_seller];\n    }\n    \n   \n    function getTotalnumberofProducts() external view returns (uint256) {\n        return productCounter;\n    }\n    \n\n    function reduceStock(uint256 _productId, uint256 _quantity) \n        external \n        validProduct(_productId) \n    {\n        Product storage product = products[_productId];\n        require(product.stock >= _quantity, \"Insufficient stock\");\n        product.stock -= _quantity;\n    }\n    \n\n    function isProductAvailable(uint256 _productId, uint256 _quantity) \n        external \n        view \n        validProduct(_productId) \n        returns (bool) \n    {\n        Product memory product = products[_productId];\n        return product.isActive && product.stock >= _quantity;\n    }\n}\ninterface IProductListing {\n    function getProduct(uint256 _productId) external view returns (\n        uint256 id,\n        address seller,\n        string memory name,\n        string memory description,\n        string memory ipfsHash,\n        uint256 price,\n        uint256 stock,\n        bool isActive,\n        uint256 createdAt\n    );\n    \n    function isProductAvailable(uint256 _productId, uint256 _quantity) external view returns (bool);\n}\n\n\ncontract MarketplaceEscrow {\n    \n    // Order status enum\n    enum OrderStatus {\n        Pending,        // Payment locked in escrow\n        Shipped,        // Seller marked as shipped\n        Delivered,      // Buyer confirmed delivery\n        Cancelled       // Order cancelled/refunded\n    }\n    \n    // Order struct\n    struct Order {\n        uint256 orderId;\n        uint256 productId;\n        address buyer;\n        address seller;\n        uint256 quantity;\n        uint256 totalPrice;\n        OrderStatus status;\n        uint256 createdAt;\n        uint256 deliveredAt;\n    }\n    \n    // State variables\n    IProductListing public productListing;\n    uint256 private orderCounter;\n    mapping(uint256 => Order) public orders;\n    mapping(address => uint256[]) private buyerOrders;\n    mapping(address => uint256[]) private sellerOrders;\n    \n    // Platform fee (2.5% = 250 basis points)\n    uint256 public platformFee = 250;\n    uint256 constant FEE_DENOMINATOR = 10000;\n    address public platformWallet;\n    \n    // Events\n    event OrderCreated(\n        uint256 indexed orderId,\n        uint256 indexed productId,\n        address indexed buyer,\n        address seller,\n        uint256 quantity,\n        uint256 totalPrice\n    );\n    \n    event OrderShipped(uint256 indexed orderId);\n    event OrderDelivered(uint256 indexed orderId);\n    event OrderCancelled(uint256 indexed orderId);\n    event FundsReleased(uint256 indexed orderId, address seller, uint256 amount);\n    \n    // Modifiers\n    modifier onlyBuyer(uint256 _orderId) {\n        require(orders[_orderId].buyer == msg.sender, \"Not the buyer\");\n        _;\n    }\n    \n    modifier onlySeller(uint256 _orderId) {\n        require(orders[_orderId].seller == msg.sender, \"Not the seller\");\n        _;\n    }\n    \n    modifier validOrder(uint256 _orderId) {\n        require(_orderId > 0 && _orderId <= orderCounter, \"Invalid order ID\");\n        _;\n    }\n    \n    constructor(address _productListingAddress, address _platformWallet) {\n        require(_productListingAddress != address(0), \"Invalid product listing address\");\n        require(_platformWallet != address(0), \"Invalid platform wallet\");\n        productListing = IProductListing(_productListingAddress);\n        platformWallet = _platformWallet;\n    }\n    \n   \n    function buyProduct(uint256 _productId, uint256 _quantity) \n        external \n        payable \n        returns (uint256) \n    {\n        require(_quantity > 0, \"Quantity must be greater than 0\");\n        \n        // Get product details from ProductListing contract\n        (\n            ,\n            address seller,\n            ,\n            ,\n            ,\n            uint256 price,\n            ,\n            ,\n        ) = productListing.getProduct(_productId);\n        \n        require(seller != address(0), \"Product does not exist\");\n        require(seller != msg.sender, \"Cannot buy your own product\");\n        \n        // Check product availability\n        require(\n            productListing.isProductAvailable(_productId, _quantity),\n            \"Product not available\"\n        );\n        \n        // Calculate total price\n        uint256 totalPrice = price * _quantity;\n        require(msg.value == totalPrice, \"Incorrect payment amount\");\n        \n        // Create order\n        orderCounter++;\n        orders[orderCounter] = Order({\n            orderId: orderCounter,\n            productId: _productId,\n            buyer: msg.sender,\n            seller: seller,\n            quantity: _quantity,\n            totalPrice: totalPrice,\n            status: OrderStatus.Pending,\n            createdAt: block.timestamp,\n            deliveredAt: 0\n        });\n        \n        // Track orders\n        buyerOrders[msg.sender].push(orderCounter);\n        sellerOrders[seller].push(orderCounter);\n        \n        emit OrderCreated(\n            orderCounter,\n            _productId,\n            msg.sender,\n            seller,\n            _quantity,\n            totalPrice\n        );\n        \n        return orderCounter;\n    }\n    \n    \n    function markAsShipped(uint256 _orderId) \n        external \n        validOrder(_orderId)\n        onlySeller(_orderId) \n    {\n        Order storage order = orders[_orderId];\n        require(order.status == OrderStatus.Pending, \"Order not in pending state\");\n        \n        order.status = OrderStatus.Shipped;\n        \n        emit OrderShipped(_orderId);\n    }\n    \n   \n    function confirmDelivery(uint256 _orderId) \n        external \n        validOrder(_orderId)\n        onlyBuyer(_orderId) \n    {\n        Order storage order = orders[_orderId];\n        require(order.status == OrderStatus.Shipped, \"Order not shipped yet\");\n        \n        order.status = OrderStatus.Delivered;\n        order.deliveredAt = block.timestamp;\n        \n        // Calculate platform fee\n        uint256 fee = (order.totalPrice * platformFee) / FEE_DENOMINATOR;\n        uint256 sellerAmount = order.totalPrice - fee;\n        \n        // Transfer funds\n        (bool successSeller, ) = payable(order.seller).call{value: sellerAmount}(\"\");\n        require(successSeller, \"Seller payment failed\");\n        \n        (bool successPlatform, ) = payable(platformWallet).call{value: fee}(\"\");\n        require(successPlatform, \"Platform fee transfer failed\");\n        \n        emit OrderDelivered(_orderId);\n        emit FundsReleased(_orderId, order.seller, sellerAmount);\n    }\n    \n   \n    function cancelOrder(uint256 _orderId) \n        external \n        validOrder(_orderId)\n        onlyBuyer(_orderId) \n    {\n        Order storage order = orders[_orderId];\n        require(order.status == OrderStatus.Pending, \"Can only cancel pending orders\");\n        \n        order.status = OrderStatus.Cancelled;\n        \n        // Refund buyer\n        (bool success, ) = payable(order.buyer).call{value: order.totalPrice}(\"\");\n        require(success, \"Refund failed\");\n        \n        emit OrderCancelled(_orderId);\n    }\n    \n    \n    function getOrder(uint256 _orderId) \n        external \n        view \n        validOrder(_orderId)\n        returns (\n            uint256 orderId,\n            uint256 productId,\n            address buyer,\n            address seller,\n            uint256 quantity,\n            uint256 totalPrice,\n            OrderStatus status,\n            uint256 createdAt,\n            uint256 deliveredAt\n        ) \n    {\n        Order memory order = orders[_orderId];\n        return (\n            order.orderId,\n            order.productId,\n            order.buyer,\n            order.seller,\n            order.quantity,\n            order.totalPrice,\n            order.status,\n            order.createdAt,\n            order.deliveredAt\n        );\n    }\n    \n    /**\n     * @dev Get all orders for a buyer\n     * @param _buyer Buyer address\n     */\n    function getBuyerOrders(address _buyer) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return buyerOrders[_buyer];\n    }\n    \n    /**\n     * @dev Get all orders for a seller\n     * @param _seller Seller address\n     */\n    function getSellerOrders(address _seller) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return sellerOrders[_seller];\n    }\n    \n    /**\n     * @dev Get total number of orders\n     */\n    function getTotalOrders() external view returns (uint256) {\n        return orderCounter;\n    }\n    \n    /**\n     * @dev Check order status\n     * @param _orderId Order ID\n     */\n    function getOrderStatus(uint256 _orderId) \n        external \n        view \n        validOrder(_orderId)\n        returns (OrderStatus) \n    {\n        return orders[_orderId].status;\n    }\n}"
      }
    }
  }
}